- hosts: localhost
  connection: local
  gather_facts: no
  tasks:
    - name: Importing the variables file
      include_vars: vars/outputs

    - name: Importing the bashion variable
      include_vars: proj_stack

    - name: Create a new EC2 key pair
      ec2_key:
        name: stack_key
        region: "{{ region }}"
      register: keyout

    - name: Store the key in the file
      copy:
        content: "{{ keyout.key.private_key }}"
        dest: "./stack_key.pem"
        mode: '0600'
      when: keyout.changed

    - name: Create security group rule for elb
      ec2_group:
        name: proj-elb
        description: leb with the description
        region: "{{ region }}"
        vpc_id: "{{ vpc_id }}"
        rules:
          - proto: tcp
            from_port: 80
            to_port: 80
            cidr_ip: [0.0.0.0/0]
            rule_desc: allow 80 to anywhere

          - proto: tcp
            from_port: 22
            to_port: 22
            group_id: "{{ bashionSG }}"  # Reference a security group ID
            rule_desc: allow 22 from bastion

      register: elbSG_out

    - name: Create security group rule for proj_stack
      ec2_group:
        name: proj_stack-sg
        description: proj_stack with the description
        region: "{{ region }}"
        vpc_id: "{{ vpc_id }}"
        rules:
          - proto: tcp
            from_port: 80
            to_port: 80
            cidr_ip: "0.0.0.0/0"  # Open to the internet
            rule_desc: allow 80 to anywhere

          - proto: tcp
            from_port: 22
            to_port: 22
            group_id: "{{ bashionSG }}"  # Correct parameter name
            rule_desc: allow 22 to bastion
      register: projSG_out


    - name: Updating the proj_stack to connect with themselves
      ec2_group:
        name: proj_stack-sg
        region: "{{ region }}"
        rules:
          - proto: all
            from_port: -1
            to_port: -1
            group_id: "{{ projSG_out.group_id }}"  # Reference the correct group ID
            rule_desc: allow within proj_stack itself  # Adding the missing description
        description: Allow all traffic within proj_stack  # Required field


    - name: Creating RMQ Host  # Adding "name" field
      amazon.aws.ec2_instance:
        key_name: stack_key  # Ensure this matches the created key name
        region: "{{ region }}"  # Ensure the region variable is defined
        instance_type: t2.micro
        vpc_subnet_id: "{{ privsub1_id }}"  # Ensure this variable is defined
        image_id: "{{ rmq_ami }}"  # Make sure this AMI ID is valid in the specified region
        wait: yes
        wait_timeout: 300
        tags: # Use 'tags' instead of 'instance_tags'
          Name: "rmq"
          Owner: "Devops"
        exact_count: 1
        security_groups: # Specify your security groups here
          - "{{ projSG_out.group_id }}"  # Ensure this variable is defined
      register: rmq_out

    - name: Creating web Host for nginx  # Adding "name" field
      amazon.aws.ec2_instance:
        key_name: stack_key  # Ensure this matches the created key name
        region: "{{ region }}"  # Ensure the region variable is defined
        instance_type: t2.micro
        vpc_subnet_id: "{{ privsub1_id }}"  # Ensure this variable is defined
        image_id: "{{ nginx_ami }}"  # Make sure this AMI ID is valid in the specified region
        wait: yes
        wait_timeout: 300
        tags: # Use 'tags' instead of 'instance_tags'
          Name: "web"
          Owner: "Devops"
        exact_count: 1
        security_groups: # Specify your security groups here
          - "{{ projSG_out.group_id }}"  # Ensure this variable is defined
      register: web_out

    - name: Creating db Host  # Adding "name" field
      amazon.aws.ec2_instance:
        key_name: stack_key  # Ensure this matches the created key name
        region: "{{ region }}"  # Ensure the region variable is defined
        instance_type: t2.micro
        vpc_subnet_id: "{{ privsub1_id }}"  # Ensure this variable is defined
        image_id: "{{ mqsql_ami }}"  # Make sure this AMI ID is valid in the specified region
        wait: yes
        wait_timeout: 300
        tags: # Use 'tags' instead of 'instance_tags'
          Name: "db"
          Owner: "Devops"
        exact_count: 1
        security_groups: # Specify your security groups here
          - "{{ projSG_out.group_id }}"  # Ensure this variable is defined
      register: db_out

    - name: Creating memcache Host  # Adding "name" field
      amazon.aws.ec2_instance:
        key_name: stack_key  # Ensure this matches the created key name
        region: "{{ region }}"  # Ensure the region variable is defined
        instance_type: t2.micro
        vpc_subnet_id: "{{ privsub1_id }}"  # Ensure this variable is defined
        image_id: "{{ memcache_ami }}"  # Make sure this AMI ID is valid in the specified region
        wait: yes
        wait_timeout: 300
        tags: # Use 'tags' instead of 'instance_tags'
          Name: "memcached"
          Owner: "Devops"
        exact_count: 1
        security_groups: # Specify your security groups here
          - "{{ projSG_out.group_id }}"  # Ensure this variable is defined
      register: memcached_out

    - name: Creating tomcat app Host  # Adding "name" field
      amazon.aws.ec2_instance:
        key_name: stack_key  # Ensure this matches the created key name
        region: "{{ region }}"  # Ensure the region variable is defined
        instance_type: t2.micro
        vpc_subnet_id: "{{ privsub1_id }}"  # Ensure this variable is defined
        image_id: "{{ tomcat_ami }}"  # Make sure this AMI ID is valid in the specified region
        wait: yes
        wait_timeout: 300
        tags: # Use 'tags' instead of 'instance_tags'
          Name: "app"
          Owner: "Devops"
        exact_count: 1
        security_groups: # Specify your security groups here
          - "{{ projSG_out.group_id }}"  # Ensure this variable is defined
      register: app_out


    - name: Elastic Load Balancer
      elb_classic_lb:
        name: "proj-elb"
        region: "{{ region }}"
        scheme: internal
        state: present
        instance_ids: "{{ web_out.instance_ids }}"  # List of instance IDs you want to register with the ELB
        purge_instance_ids: true
        subnets:
          - "{{ pubsub1_id }}"
          - "{{ pubsub2_id }}"
        listeners:
          - protocol: http
            load_balancer_port: 80
            instance_port: 80
      register: elb_out

    - name: Debug web_out variable
      debug:
        msg: "web_out: {{ web_out }}"

    - name: Storing the private key for services in provisioned file
      blockinfile:
        path: provision/group_vars/hostip
        block: |
          web_ip: {{ web_out.instances[0].private_ip_address }}
          app_ip: {{ app_out.instances[0].private_ip_address }}
          db_ip: {{ db_out.instances[0].private_ip_address }}
          memcached_ip: {{ memcached_out.instances[0].private_ip_address }}
          rmq_ip: {{ rmq_out.instances[0].private_ip_address }}



    - name: Copying the login key into the provision_Stack
      copy:
        src: stack_key.pem
        dest: provision/login_key.pem
        mode: '0600'

    - name: Updating and storing it in the inventory file
      blockinfile:
        path: provision/inventory.yml
        block: |
          web ansible_host={{ web_out.instances[0].private_ip_address }}
          app ansible_host={{ app_out.instances[0].private_ip_address }}
          memcached ansible_host={{ memcached_out.instances[0].private_ip_address }}
          rmq ansible_host={{ rmq_out.instances[0].private_ip_address }}
          db ansible_host={{ db_out.instances[0].private_ip_address }}
          control ansible_host=127.0.0.1 ansible_connection=local

          [websrvgrp]
          web

          [appsrvgrp]
          app

          [memcached]
          memcached

          [rmqsrvgrp]
          rmq

          [dbsrvgrp]
          db

          [controlsrvgrp]
          control

          [stack_instance:children]
          websrvgrp
          appsrvgrp
          memcached
          rmqsrvgrp
          dbsrvgrp
          controlsrvgrp

          [stack_instance:vars]
          ansible_user=ubuntu
          ansible_ssh_private_key_file=stack_key.pem
          ansible_python_interpreter=/usr/bin/python3

        
